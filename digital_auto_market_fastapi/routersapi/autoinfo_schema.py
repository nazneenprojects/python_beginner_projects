from pydantic import BaseModel, Field, condecimal, constr, validator
from typing import Optional

class AutoInfoBase(BaseModel):
    vehicle_name: str = Field(..., example="Volkswagen Golf")  # Required string
    vehicle_model: str = Field(..., example="GTI")  # Required string
    num_wheel: int = Field(..., example=4)  # Number of wheels, required integer
    type: str = Field(..., example="ev")
    year: int = Field(..., ge=1886, example=2022)  # Year with constraint (1886 onward)
    brand: str = Field(..., example="VW")  # Required string
    price: condecimal(max_digits=18, decimal_places=2) = Field(..., example=25000.00)  # Price with 2 decimal precision
    available: bool = Field(default=True)  # Default is True
    reserved: bool = Field(default=False)  # Default is False
    count: int = Field(default=0, example=3)  # Default count of available vehicles
    v_id: int = Field(default=0)

    @validator('type')
    def validate_type(cls, v):
        if v not in ('ev', 'non-ev'):
            raise ValueError('Type must be "ev" or "non-ev"')
        return v

    class Config:
        orm_mode = True  # Required to work with SQLAlchemy models


# Schema for reading data (response)
class AutoInfo(AutoInfoBase):
    id: int  # Auto-generated by the database


# Schema for creating new AutoInfo records (request)
class AutoInfoCreate(AutoInfoBase):
    pass  # All fields are inherited from AutoInfoBase


# Schema for updating AutoInfo records (request)
class AutoInfoUpdate(BaseModel):
    vehicle_name: Optional[str] = None
    vehicle_model: Optional[str] = None
    num_wheel: Optional[int] = None
    type: Optional[str] = Field(None, example="ev")  # Optional field
    year: Optional[int] = Field(None, ge=1886)
    brand: Optional[str] = None
    price: Optional[condecimal(max_digits=18, decimal_places=2)] = None
    available: Optional[bool] = None
    reserved: Optional[bool] = None
    count: Optional[int] = None


    class Config:
        orm_mode = True

